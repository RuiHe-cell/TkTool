#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ä»£ç ç¼–è¾‘å™¨ç»„ä»¶
åŠŸèƒ½ï¼šæä¾›å¸¦æœ‰åŸºæœ¬ç¼–è¾‘åŠŸèƒ½å’Œè¯­æ³•é«˜äº®çš„ä»£ç ç¼–è¾‘çª—å£
"""

import tkinter as tk
from tkinter import ttk, messagebox
from typing import Optional, Callable
from .SyntaxHighlighter import SyntaxHighlighter
import keyword
import builtins
import re


# æ·»åŠ DeepSeekç›¸å…³å¯¼å…¥
import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
from deepseek_api.deepseek_dialog import DeepSeekDialog, ApiKeyDialog
from deepseek_api.api_key_manager import ApiKeyManager
from deepseek_api.prompt_template import generate_test_data_prompt


class CodeEditor:
    """ä»£ç ç¼–è¾‘å™¨ç±»"""

    def __init__(self, parent, title: str = "ä»£ç ç¼–è¾‘å™¨",
                 initial_code: str = "",
                 template_code: str = "",
                 on_save: Optional[Callable[[str], None]] = None,
                 width: int = 700, height: int = 600,
                 language: str = "python"):
        """
        åˆå§‹åŒ–ä»£ç ç¼–è¾‘å™¨
        
        Args:
            parent: çˆ¶çª—å£
            title: ç¼–è¾‘å™¨çª—å£æ ‡é¢˜
            initial_code: åˆå§‹ä»£ç å†…å®¹
            template_code: æ¨¡æ¿ä»£ç ï¼ˆå½“initial_codeä¸ºç©ºæ—¶ä½¿ç”¨ï¼‰
            on_save: ä¿å­˜å›è°ƒå‡½æ•°
            width: çª—å£å®½åº¦
            height: çª—å£é«˜åº¦
            language: ç¼–ç¨‹è¯­è¨€ç±»å‹
        """
        self.parent = parent
        self.title = title
        self.initial_code = initial_code
        self.template_code = template_code
        self.on_save = on_save
        self.width = width
        self.height = height
        self.language = language

        self.editor_window = None
        self.code_text = None
        self.saved_code = ""
        self.highlighter = None

        # è‡ªåŠ¨è¡¥å…¨ç›¸å…³å±æ€§
        self.completion_window = None
        self.completion_listbox = None
        self.completion_candidates = []
        self.completion_start_pos = None
        self.completion_prefix = ""
        
        # Python å…³é”®å­—å’Œå†…ç½®å‡½æ•°
        self.python_keywords = keyword.kwlist
        self.python_builtins = dir(builtins)

    def show(self) -> str:
        """æ˜¾ç¤ºç¼–è¾‘å™¨çª—å£å¹¶è¿”å›ç¼–è¾‘åçš„ä»£ç """
        self.create_editor_window()
        self.parent.wait_window(self.editor_window)
        return self.saved_code

    def create_editor_window(self):
        """åˆ›å»ºç¼–è¾‘å™¨çª—å£"""
        self.editor_window = tk.Toplevel(self.parent)
        self.editor_window.title(self.title)
        self.editor_window.geometry(f"{self.width}x{self.height}")
        self.editor_window.transient(self.parent.winfo_toplevel())
        self.editor_window.grab_set()

        # åˆ›å»ºä¸»æ¡†æ¶
        main_frame = ttk.Frame(self.editor_window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # åˆ›å»ºæ–‡æœ¬ç¼–è¾‘åŒºåŸŸ
        self.create_text_area(main_frame)

        # åˆ›å»ºæŒ‰é’®åŒºåŸŸ
        self.create_button_area(main_frame)

        # åˆå§‹åŒ–ä»£ç å†…å®¹
        self.initialize_code_content()

        # è®¾ç½®ç„¦ç‚¹åˆ°æ–‡æœ¬æ¡†
        self.code_text.focus_set()

    def create_embedded_editor(self, parent):
        """åˆ›å»ºåµŒå…¥å¼ç¼–è¾‘å™¨ï¼ˆä¸æ˜¯å¼¹çª—æ¨¡å¼ï¼‰"""
        # åˆ›å»ºæ–‡æœ¬ç¼–è¾‘åŒºåŸŸ
        self.create_text_area(parent)

        # ç»‘å®šäº‹ä»¶
        self.bind_editor_events()

        # åˆå§‹åŒ–è¯­æ³•é«˜äº®å™¨
        if not self.highlighter:
            self.highlighter = SyntaxHighlighter(self.code_text, self.language)

        # åˆå§‹åŒ–ä»£ç å†…å®¹
        self.initialize_code_content()

        # è®¾ç½®ç„¦ç‚¹åˆ°æ–‡æœ¬æ¡†
        self.code_text.focus_set()

    def create_text_area(self, parent):
        """åˆ›å»ºæ–‡æœ¬ç¼–è¾‘åŒºåŸŸ"""
        text_frame = ttk.Frame(parent)
        text_frame.pack(fill=tk.BOTH, expand=True)

        # ä»£ç æ–‡æœ¬æ¡†
        self.code_text = tk.Text(text_frame,
                                 wrap=tk.NONE,
                                 font=("Consolas", 11),
                                 insertwidth=2,
                                 selectbackground="#316AC5",
                                 selectforeground="white",
                                 bg="#FFFFFF",
                                 fg="#000000",
                                 insertbackground="#000000",
                                 undo=True,  # å¯ç”¨æ’¤é”€åŠŸèƒ½
                                 maxundo=50)  # è®¾ç½®æœ€å¤§æ’¤é”€æ¬¡æ•°

        # æ»šåŠ¨æ¡
        v_scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=self.code_text.yview)
        h_scrollbar = ttk.Scrollbar(text_frame, orient=tk.HORIZONTAL, command=self.code_text.xview)
        self.code_text.config(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)

        # å¸ƒå±€
        self.code_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        v_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        h_scrollbar.grid(row=1, column=0, sticky=(tk.W, tk.E))

        text_frame.columnconfigure(0, weight=1)
        text_frame.rowconfigure(0, weight=1)

        # åˆ›å»ºè¯­æ³•é«˜äº®å™¨
        self.highlighter = SyntaxHighlighter(self.code_text, self.language)

        # ç»‘å®šç¼–è¾‘åŠŸèƒ½äº‹ä»¶
        self.bind_editor_events()

    def bind_editor_events(self):
        """ç»‘å®šç¼–è¾‘å™¨äº‹ä»¶"""
        # Tabé”®è½¬æ¢ä¸º4ä¸ªç©ºæ ¼
        self.code_text.bind('<Tab>', self.handle_tab)

        # Shift+Tabå‡å°‘ç¼©è¿›
        self.code_text.bind('<Shift-Tab>', self.handle_shift_tab)

        # Enteré”®è‡ªåŠ¨ç¼©è¿›
        self.code_text.bind('<Return>', self.handle_return)

        # æ™ºèƒ½é€€æ ¼é”®
        self.code_text.bind('<BackSpace>', self.handle_backspace)

        # Ctrl+Sä¿å­˜
        self.code_text.bind('<Control-s>', lambda e: self.save_code())

        # Ctrl+/ å¿«é€Ÿæ³¨é‡Š/å–æ¶ˆæ³¨é‡Š
        self.code_text.bind('<Control-slash>', self.toggle_comment)

        # Ctrl+Z æ’¤é”€
        self.code_text.bind('<Control-z>', self.handle_undo)

        # Ctrl+Y é‡åš (æˆ– Ctrl+Shift+Z)
        self.code_text.bind('<Control-y>', self.handle_redo)
        self.code_text.bind('<Control-Shift-Z>', self.handle_redo)

        # æ‹¬å·è‡ªåŠ¨è¡¥å…¨
        self.code_text.bind('<KeyPress>', self.handle_auto_complete)

        # ç»‘å®šå†…å®¹å˜åŒ–äº‹ä»¶ä»¥è§¦å‘è¯­æ³•é«˜äº®
        self.code_text.bind('<KeyRelease>', self.on_key_release)
        self.code_text.bind('<Button-1>', self.hide_completion)
        # æ³¨é‡Šæ‰è¿™è¡Œï¼Œé¿å…ç„¦ç‚¹ä¸¢å¤±æ—¶ç«‹å³éšè—è¡¥å…¨çª—å£
        # self.code_text.bind('<FocusOut>', self.hide_completion)
        self.code_text.bind('<ButtonRelease-1>', self.on_text_change)
        # ç»‘å®šç²˜è´´äº‹ä»¶
        self.code_text.bind('<Control-v>', self.on_paste)
        # ç»‘å®šåˆ é™¤äº‹ä»¶
        self.code_text.bind('<Delete>', self.on_text_change)

        # ç»‘å®šæ»šåŠ¨äº‹ä»¶ä»¥è§¦å‘å¯è§åŒºåŸŸé«˜äº®
        self.code_text.bind('<MouseWheel>', self.on_scroll)
        self.code_text.bind('<Button-4>', self.on_scroll)  # Linux
        self.code_text.bind('<Button-5>', self.on_scroll)  # Linux

        # åˆå§‹åŒ–è¯­æ³•é«˜äº®å™¨
        self.syntax_highlighter = SyntaxHighlighter(self.code_text, self.language)

    def on_text_change(self, event=None):
        """æ–‡æœ¬å†…å®¹å˜åŒ–æ—¶çš„å¤„ç†ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰"""
        if self.highlighter:
            # ä½¿ç”¨é˜²æŠ–çš„è¯­æ³•é«˜äº®
            self.highlighter.highlight_syntax_debounced()
    
    def on_paste(self, event=None):
        """å¤„ç†ç²˜è´´äº‹ä»¶ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰"""
        if self.highlighter:
            # ç²˜è´´åå»¶è¿Ÿè§¦å‘é˜²æŠ–é«˜äº®
            self.code_text.after(100, self.highlighter.highlight_syntax_debounced)
        return None
    
    def on_scroll(self, event=None):
        """æ»šåŠ¨æ—¶è§¦å‘å¯è§åŒºåŸŸé«˜äº®"""
        if self.highlighter:
            # å»¶è¿Ÿè§¦å‘ä»¥é¿å…æ»šåŠ¨æ—¶é¢‘ç¹æ›´æ–°
            self.code_text.after(200, self.highlighter.highlight_visible_area)

    def on_key_release(self, event):
        """æŒ‰é”®é‡Šæ”¾äº‹ä»¶å¤„ç†"""
        # å¦‚æœè¡¥å…¨çª—å£å¼€å¯ï¼ŒæŸäº›æŒ‰é”®åº”è¯¥è¢«è¡¥å…¨çª—å£å¤„ç†
        if self.completion_window:
            if event.keysym in ['Up', 'Down']:
                # ä¸Šä¸‹é”®å¯¼èˆªè¡¥å…¨åˆ—è¡¨
                self.handle_completion_navigation(event)
                return "break"
            elif event.keysym in ['Return', 'Tab']:
                # å›è½¦æˆ–Tabæ¥å—è¡¥å…¨
                self.accept_completion()
                return "break"
            elif event.keysym == 'Escape':
                # Escapeéšè—è¡¥å…¨çª—å£
                self.hide_completion()
                return "break"
            elif event.keysym in ['Left', 'Right']:
                # å·¦å³é”®éšè—è¡¥å…¨çª—å£
                self.hide_completion()

        # å¤„ç†è‡ªåŠ¨è¡¥å…¨è§¦å‘
        if event.char and event.char.isprintable():
            # å…ˆå¤„ç†æ–‡æœ¬å˜åŒ–ï¼Œå†æ˜¾ç¤ºè¡¥å…¨
            self.on_text_change(event)
            self.show_completion()
            return

        # å¯¹äºå…¶ä»–æŒ‰é”®ï¼Œå¤„ç†æ–‡æœ¬å˜åŒ–
        self.on_text_change(event)

    def handle_completion_navigation(self, event):
        """å¤„ç†è¡¥å…¨çª—å£çš„å¯¼èˆªé”®"""
        if not self.completion_listbox:
            return

        current_selection = self.completion_listbox.curselection()
        if not current_selection:
            self.completion_listbox.selection_set(0)
            return

        current_index = current_selection[0]

        if event.keysym == 'Down':
            new_index = min(current_index + 1, self.completion_listbox.size() - 1)
        elif event.keysym == 'Up':
            new_index = max(current_index - 1, 0)
        else:
            return

        self.completion_listbox.selection_clear(0, tk.END)
        self.completion_listbox.selection_set(new_index)
        self.completion_listbox.see(new_index)

    def show_completion(self):
        """æ˜¾ç¤ºè‡ªåŠ¨è¡¥å…¨çª—å£"""
        try:
            # è·å–å½“å‰å…‰æ ‡ä½ç½®
            cursor_pos = self.code_text.index(tk.INSERT)
            line, col = map(int, cursor_pos.split('.'))

            # è·å–å½“å‰è¡Œå†…å®¹
            line_start = f"{line}.0"
            line_end = f"{line}.end"
            line_content = self.code_text.get(line_start, line_end)

            # æ£€æŸ¥æ˜¯å¦æ˜¯å¯¹è±¡æ–¹æ³•è°ƒç”¨ï¼ˆå¦‚ a.ï¼‰
            dot_pos = line_content.rfind('.', 0, col)
            if dot_pos != -1 and dot_pos < col:
                # æ‰¾åˆ°ç‚¹æ“ä½œç¬¦ï¼Œè·å–å¯¹è±¡åå’Œæ–¹æ³•å‰ç¼€
                obj_start = dot_pos - 1
                while obj_start >= 0 and (line_content[obj_start].isalnum() or line_content[obj_start] == '_'):
                    obj_start -= 1
                obj_start += 1

                object_name = line_content[obj_start:dot_pos]
                method_prefix = line_content[dot_pos + 1:col]

                # è·å–å¯¹è±¡æ–¹æ³•è¡¥å…¨å€™é€‰é¡¹
                candidates = self.get_object_method_candidates(object_name, method_prefix, line_content)

                if candidates:
                    # ä¿å­˜è¡¥å…¨ä¿¡æ¯
                    self.completion_prefix = method_prefix
                    self.completion_start_pos = f"{line}.{dot_pos + 1}"
                    self.completion_candidates = candidates
                    # åˆ›å»ºæˆ–æ›´æ–°è¡¥å…¨çª—å£
                    self.create_completion_window(cursor_pos)
                    return
                else:
                    self.hide_completion()
                    return

            # å¸¸è§„æ ‡è¯†ç¬¦è¡¥å…¨
            # æ‰¾åˆ°å½“å‰å•è¯çš„å¼€å§‹ä½ç½®
            word_start = col
            while word_start > 0 and (line_content[word_start - 1].isalnum() or line_content[word_start - 1] == '_'):
                word_start -= 1

            # è·å–å½“å‰è¾“å…¥çš„å‰ç¼€
            prefix = line_content[word_start:col]

            if len(prefix) < 1:  # è‡³å°‘è¾“å…¥1ä¸ªå­—ç¬¦æ‰æ˜¾ç¤ºè¡¥å…¨
                self.hide_completion()
                return

            # è·å–è¡¥å…¨å€™é€‰é¡¹
            candidates = self.get_completion_candidates(prefix)

            if not candidates:
                self.hide_completion()
                return

            # ä¿å­˜è¡¥å…¨ä¿¡æ¯
            self.completion_prefix = prefix
            self.completion_start_pos = f"{line}.{word_start}"
            self.completion_candidates = candidates

            # åˆ›å»ºæˆ–æ›´æ–°è¡¥å…¨çª—å£
            self.create_completion_window(cursor_pos)

        except Exception as e:
            print(f"è¡¥å…¨æ˜¾ç¤ºé”™è¯¯: {e}")
            self.hide_completion()

    def get_object_method_candidates(self, object_name, method_prefix, full_line):
        """è·å–å¯¹è±¡æ–¹æ³•è¡¥å…¨å€™é€‰é¡¹"""
        candidates = []
        method_prefix_lower = method_prefix.lower()

        # å°è¯•åˆ†æå¯¹è±¡ç±»å‹
        object_type = self.infer_object_type(object_name, full_line)

        # æ ¹æ®å¯¹è±¡ç±»å‹è·å–æ–¹æ³•
        methods = self.get_methods_for_type(object_type)

        for method_name, method_info in methods.items():
            if method_name.lower().startswith(method_prefix_lower):
                candidates.append((method_name, method_info['type'], method_info.get('auto_parentheses', False)))

        # æ’åºå€™é€‰é¡¹ï¼šå¸¸ç”¨æ–¹æ³•ä¼˜å…ˆ
        candidates.sort(key=lambda x: (x[1] != "method", x[0].lower()))

        return candidates[:15]  # é™åˆ¶æ˜¾ç¤ºæ•°é‡

    def infer_object_type(self, object_name, full_line):
        """æ¨æ–­å¯¹è±¡ç±»å‹"""
        # è·å–æ•´ä¸ªæ–‡ä»¶å†…å®¹è¿›è¡Œåˆ†æ
        try:
            code = self.code_text.get(1.0, tk.END)
            lines = code.split('\n')

            # æŸ¥æ‰¾å˜é‡èµ‹å€¼è¯­å¥
            for line in lines:
                line = line.strip()
                if f"{object_name} = " in line:
                    # ç®€å•çš„ç±»å‹æ¨æ–­
                    if '"' in line or "'" in line:
                        return "str"
                    elif "[" in line and "]" in line:
                        return "list"
                    elif "{" in line and "}" in line:
                        if ":" in line:
                            return "dict"
                        else:
                            return "set"
                    elif line.endswith(".split(") or ".strip(" in line:
                        return "str"
                    elif "int(" in line:
                        return "int"
                    elif "float(" in line:
                        return "float"
                    elif "range(" in line:
                        return "range"

            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ˜ç¡®çš„èµ‹å€¼ï¼Œè¿”å›é€šç”¨ç±»å‹
            return "object"

        except:
            return "object"

    def get_methods_for_type(self, object_type):
        """æ ¹æ®ç±»å‹è·å–å¯ç”¨æ–¹æ³•"""
        methods = {}

        if object_type == "str":
            str_methods = {
                'upper': {'type': 'method', 'auto_parentheses': True},
                'lower': {'type': 'method', 'auto_parentheses': True},
                'strip': {'type': 'method', 'auto_parentheses': True},
                'lstrip': {'type': 'method', 'auto_parentheses': True},
                'rstrip': {'type': 'method', 'auto_parentheses': True},
                'split': {'type': 'method', 'auto_parentheses': True},
                'join': {'type': 'method', 'auto_parentheses': True},
                'replace': {'type': 'method', 'auto_parentheses': True},
                'find': {'type': 'method', 'auto_parentheses': True},
                'index': {'type': 'method', 'auto_parentheses': True},
                'startswith': {'type': 'method', 'auto_parentheses': True},
                'endswith': {'type': 'method', 'auto_parentheses': True},
                'isdigit': {'type': 'method', 'auto_parentheses': True},
                'isalpha': {'type': 'method', 'auto_parentheses': True},
                'isalnum': {'type': 'method', 'auto_parentheses': True},
                'capitalize': {'type': 'method', 'auto_parentheses': True},
                'title': {'type': 'method', 'auto_parentheses': True},
                'format': {'type': 'method', 'auto_parentheses': True},
                'count': {'type': 'method', 'auto_parentheses': True},
                'encode': {'type': 'method', 'auto_parentheses': True},
                'decode': {'type': 'method', 'auto_parentheses': True}
            }
            methods.update(str_methods)

        elif object_type == "list":
            list_methods = {
                'append': {'type': 'method', 'auto_parentheses': True},
                'extend': {'type': 'method', 'auto_parentheses': True},
                'insert': {'type': 'method', 'auto_parentheses': True},
                'remove': {'type': 'method', 'auto_parentheses': True},
                'pop': {'type': 'method', 'auto_parentheses': True},
                'clear': {'type': 'method', 'auto_parentheses': True},
                'index': {'type': 'method', 'auto_parentheses': True},
                'count': {'type': 'method', 'auto_parentheses': True},
                'sort': {'type': 'method', 'auto_parentheses': True},
                'reverse': {'type': 'method', 'auto_parentheses': True},
                'copy': {'type': 'method', 'auto_parentheses': True}
            }
            methods.update(list_methods)

        elif object_type == "dict":
            dict_methods = {
                'keys': {'type': 'method', 'auto_parentheses': True},
                'values': {'type': 'method', 'auto_parentheses': True},
                'items': {'type': 'method', 'auto_parentheses': True},
                'get': {'type': 'method', 'auto_parentheses': True},
                'pop': {'type': 'method', 'auto_parentheses': True},
                'update': {'type': 'method', 'auto_parentheses': True},
                'clear': {'type': 'method', 'auto_parentheses': True},
                'copy': {'type': 'method', 'auto_parentheses': True},
                'setdefault': {'type': 'method', 'auto_parentheses': True}
            }
            methods.update(dict_methods)

        # æ‰€æœ‰å¯¹è±¡éƒ½æœ‰çš„é€šç”¨æ–¹æ³•
        common_methods = {
            '__str__': {'type': 'method', 'auto_parentheses': True},
            '__repr__': {'type': 'method', 'auto_parentheses': True},
            '__len__': {'type': 'method', 'auto_parentheses': True},
            '__class__': {'type': 'attribute', 'auto_parentheses': False},
            '__dict__': {'type': 'attribute', 'auto_parentheses': False}
        }
        methods.update(common_methods)

        return methods

    def get_completion_candidates(self, prefix):
        """è·å–è¡¥å…¨å€™é€‰é¡¹"""
        candidates = []
        prefix_lower = prefix.lower()

        # Python å…³é”®å­—
        for keyword_item in self.python_keywords:
            if keyword_item.lower().startswith(prefix_lower):
                candidates.append((keyword_item, "keyword", False))

        # Python å†…ç½®å‡½æ•°
        for builtin in self.python_builtins:
            if not builtin.startswith('_') and builtin.lower().startswith(prefix_lower):
                # å†…ç½®å‡½æ•°éœ€è¦è‡ªåŠ¨æ·»åŠ æ‹¬å·
                auto_parentheses = builtin in ['print', 'len', 'str', 'int', 'float', 'list', 'dict', 'set', 'tuple', 'range', 'enumerate', 'zip', 'map', 'filter', 'sorted', 'max', 'min', 'sum', 'abs', 'round', 'type', 'isinstance', 'hasattr', 'getattr', 'setattr', 'input', 'open']
                candidates.append((builtin, "builtin", auto_parentheses))

        # å½“å‰æ–‡ä»¶ä¸­çš„æ ‡è¯†ç¬¦
        file_identifiers = self.extract_identifiers_from_code()
        for identifier in file_identifiers:
            if identifier.lower().startswith(prefix_lower) and identifier != prefix:
                candidates.append((identifier, "identifier", False))

        # å»é‡å¹¶æ’åº
        unique_candidates = list(set(candidates))
        unique_candidates.sort(key=lambda x: (x[1] != "keyword", x[1] != "builtin", x[0].lower()))

        return unique_candidates[:20]  # é™åˆ¶æ˜¾ç¤ºæ•°é‡

    def extract_identifiers_from_code(self):
        """ä»å½“å‰ä»£ç ä¸­æå–æ ‡è¯†ç¬¦"""
        try:
            code = self.code_text.get(1.0, tk.END)
            # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ ‡è¯†ç¬¦
            pattern = r'\b[a-zA-Z_][a-zA-Z0-9_]*\b'
            identifiers = re.findall(pattern, code)
            # è¿‡æ»¤æ‰å…³é”®å­—å’Œå†…ç½®å‡½æ•°
            filtered = []
            for identifier in identifiers:
                if (identifier not in self.python_keywords and
                        identifier not in self.python_builtins and
                        len(identifier) > 1):
                    filtered.append(identifier)
            return list(set(filtered))
        except:
            return []

    def create_completion_window(self, cursor_pos):
        """åˆ›å»ºè‡ªåŠ¨è¡¥å…¨çª—å£"""
        if self.completion_window:
            self.completion_window.destroy()

        # åˆ›å»ºé¡¶å±‚çª—å£
        self.completion_window = tk.Toplevel(self.code_text)
        self.completion_window.wm_overrideredirect(True)
        self.completion_window.configure(bg='white', relief='solid', bd=1)

        # åˆ›å»ºåˆ—è¡¨æ¡†
        self.completion_listbox = tk.Listbox(
            self.completion_window,
            height=min(10, len(self.completion_candidates)),
            font=('Consolas', 9),
            selectmode=tk.SINGLE,
            bg='white',
            fg='black',
            selectbackground='#0078d4',
            selectforeground='white',
            relief='flat',
            bd=0
        )
        self.completion_listbox.pack(fill=tk.BOTH, expand=True)

        # å¡«å……å€™é€‰é¡¹
        for candidate_info in self.completion_candidates:
            if len(candidate_info) == 3:
                candidate, candidate_type, auto_parentheses = candidate_info
            else:
                candidate, candidate_type = candidate_info
                auto_parentheses = False
            
            # æ ¹æ®ç±»å‹æ˜¾ç¤ºä¸åŒçš„å›¾æ ‡æˆ–æ ‡è¯†
            if candidate_type == "method":
                display_text = f"ğŸ”§ {candidate}"
            elif candidate_type == "attribute":
                display_text = f"ğŸ“‹ {candidate}"
            elif candidate_type == "builtin":
                display_text = f"âš™ï¸ {candidate}"
            elif candidate_type == "keyword":
                display_text = f"ğŸ”‘ {candidate}"
            else:
                display_text = f"ğŸ“ {candidate}"
                
            self.completion_listbox.insert(tk.END, display_text)

        # é€‰ä¸­ç¬¬ä¸€é¡¹
        if self.completion_candidates:
            self.completion_listbox.selection_set(0)

        # ç»‘å®šè¡¥å…¨çª—å£çš„é”®ç›˜äº‹ä»¶
        self.completion_listbox.bind('<Double-Button-1>', lambda e: self.accept_completion())
        self.completion_listbox.bind('<Return>', lambda e: self.accept_completion())
        self.completion_listbox.bind('<Tab>', lambda e: self.accept_completion())
        self.completion_listbox.bind('<Escape>', lambda e: self.hide_completion())
        self.completion_listbox.bind('<Up>', self.handle_listbox_navigation)
        self.completion_listbox.bind('<Down>', self.handle_listbox_navigation)

        # è®¡ç®—çª—å£ä½ç½®
        self.position_completion_window(cursor_pos)

    def handle_listbox_navigation(self, event):
        """å¤„ç†è¡¥å…¨åˆ—è¡¨æ¡†çš„å¯¼èˆª"""
        current_selection = self.completion_listbox.curselection()
        if not current_selection:
            self.completion_listbox.selection_set(0)
            return "break"

        current_index = current_selection[0]

        if event.keysym == 'Down':
            new_index = min(current_index + 1, self.completion_listbox.size() - 1)
        elif event.keysym == 'Up':
            new_index = max(current_index - 1, 0)
        else:
            return

        self.completion_listbox.selection_clear(0, tk.END)
        self.completion_listbox.selection_set(new_index)
        self.completion_listbox.see(new_index)
        return "break"

    def position_completion_window(self, cursor_pos):
        """å®šä½è¡¥å…¨çª—å£ä½ç½®"""
        try:
            # è·å–å…‰æ ‡åœ¨å±å¹•ä¸Šçš„ä½ç½®
            bbox = self.code_text.bbox(cursor_pos)
            if bbox:
                x, y, width, height = bbox
                # è½¬æ¢ä¸ºå±å¹•åæ ‡
                screen_x = self.code_text.winfo_rootx() + x
                screen_y = self.code_text.winfo_rooty() + y + height + 2

                # ç¡®ä¿çª—å£ä¸ä¼šè¶…å‡ºå±å¹•è¾¹ç•Œ
                screen_width = self.completion_window.winfo_screenwidth()
                screen_height = self.completion_window.winfo_screenheight()

                # æ›´æ–°çª—å£ä»¥è·å–å®é™…å¤§å°
                self.completion_window.update_idletasks()
                window_width = self.completion_window.winfo_reqwidth()
                window_height = self.completion_window.winfo_reqheight()

                # è°ƒæ•´ä½ç½®é¿å…è¶…å‡ºå±å¹•
                if screen_x + window_width > screen_width:
                    screen_x = screen_width - window_width - 10
                if screen_y + window_height > screen_height:
                    screen_y = self.code_text.winfo_rooty() + y - window_height - 2

                self.completion_window.geometry(f"+{screen_x}+{screen_y}")
        except:
            # å¦‚æœå®šä½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
            self.completion_window.geometry("+100+100")

    def accept_completion(self):
        """æ¥å—å½“å‰é€‰ä¸­çš„è¡¥å…¨é¡¹"""
        if not self.completion_listbox or not self.completion_candidates:
            return

        current_selection = self.completion_listbox.curselection()
        if not current_selection:
            return

        selected_index = current_selection[0]
        candidate_info = self.completion_candidates[selected_index]

        if len(candidate_info) == 3:
            selected_candidate, candidate_type, auto_parentheses = candidate_info
        else:
            selected_candidate, candidate_type = candidate_info
            auto_parentheses = False

        # è®¡ç®—å½“å‰è¾“å…¥çš„ç»“æŸä½ç½®
        line, col = map(int, self.completion_start_pos.split('.'))
        current_end_pos = f"{line}.{col + len(self.completion_prefix)}"

        # æ›¿æ¢æ–‡æœ¬ - ä½¿ç”¨ä¿å­˜çš„ä½ç½®è€Œä¸æ˜¯å½“å‰å…‰æ ‡ä½ç½®
        self.code_text.delete(self.completion_start_pos, current_end_pos)

        # æ’å…¥è¡¥å…¨æ–‡æœ¬
        insert_text = selected_candidate
        if auto_parentheses and candidate_type in ["builtin", "method"]:
            insert_text += "()"
            # å°†å…‰æ ‡æ”¾åœ¨æ‹¬å·ä¹‹é—´
            self.code_text.insert(self.completion_start_pos, insert_text)
            new_cursor_pos = f"{line}.{col + len(selected_candidate) + 1}"
            self.code_text.mark_set(tk.INSERT, new_cursor_pos)
        else:
            self.code_text.insert(self.completion_start_pos, insert_text)
            # è®¾ç½®å…‰æ ‡åˆ°è¡¥å…¨æ–‡æœ¬çš„æœ«å°¾
            new_cursor_pos = f"{line}.{col + len(selected_candidate)}"
            self.code_text.mark_set(tk.INSERT, new_cursor_pos)

        # éšè—è¡¥å…¨çª—å£
        self.hide_completion()

        # è§¦å‘è¯­æ³•é«˜äº®
        self.on_text_change()

    def hide_completion(self, event=None):
        """éšè—è¡¥å…¨çª—å£"""
        if self.completion_window:
            self.completion_window.destroy()
            self.completion_window = None
            self.completion_listbox = None
            self.completion_candidates = []
            self.completion_start_pos = None
            self.completion_prefix = ""

    # ä¿®æ”¹ç°æœ‰çš„ handle_tab å’Œ handle_return æ–¹æ³•
    def handle_tab(self, event):
        """å¤„ç†Tabé”®"""
        # å¦‚æœè¡¥å…¨çª—å£æ‰“å¼€ï¼Œæ¥å—è¡¥å…¨
        if self.completion_window:
            self.accept_completion()
            return "break"

        # åŸæœ‰çš„Tabå¤„ç†é€»è¾‘
        try:
            current_pos = self.code_text.index(tk.INSERT)
            line_start = current_pos.split('.')[0] + '.0'
            line_content = self.code_text.get(line_start, current_pos)

            if self.code_text.tag_ranges(tk.SEL):
                # æœ‰é€‰ä¸­æ–‡æœ¬ï¼Œå¢åŠ ç¼©è¿›
                self.indent_selection()
            else:
                # æ’å…¥4ä¸ªç©ºæ ¼
                self.code_text.insert(tk.INSERT, "    ")

            # è§¦å‘è¯­æ³•é«˜äº®
            self.on_text_change()

        except Exception as e:
            print(f"Tabå¤„ç†é”™è¯¯: {e}")

        return "break"

    def handle_return(self, event):
        """å¤„ç†å›è½¦é”®"""
        # å¦‚æœè¡¥å…¨çª—å£æ‰“å¼€ï¼Œæ¥å—è¡¥å…¨
        if self.completion_window:
            self.accept_completion()
            return "break"

        # åŸæœ‰çš„å›è½¦å¤„ç†é€»è¾‘
        try:
            current_pos = self.code_text.index(tk.INSERT)
            current_line = int(current_pos.split('.')[0])
            line_start = f"{current_line}.0"
            line_content = self.code_text.get(line_start, current_pos)

            # è®¡ç®—å½“å‰è¡Œçš„ç¼©è¿›
            indent = ""
            for char in line_content:
                if char == ' ':
                    indent += ' '
                elif char == '\t':
                    indent += '\t'
                else:
                    break

            # æ£€æŸ¥æ˜¯å¦éœ€è¦å¢åŠ ç¼©è¿›
            stripped_line = line_content.strip()
            if stripped_line.endswith(':'):
                indent += "    "  # å¢åŠ 4ä¸ªç©ºæ ¼çš„ç¼©è¿›

            # æ’å…¥æ¢è¡Œå’Œç¼©è¿›
            self.code_text.insert(tk.INSERT, "\n" + indent)

            # è§¦å‘è¯­æ³•é«˜äº®
            self.on_text_change()

        except Exception as e:
            print(f"å›è½¦å¤„ç†é”™è¯¯: {e}")

        return "break"

    def toggle_comment(self, event):
        """åˆ‡æ¢æ³¨é‡ŠçŠ¶æ€ï¼ˆæ”¯æŒå¤šè¡Œï¼‰"""
        try:
            # è·å–é€‰ä¸­çš„æ–‡æœ¬èŒƒå›´
            if self.code_text.tag_ranges(tk.SEL):
                # æœ‰é€‰ä¸­æ–‡æœ¬ï¼Œå¤„ç†é€‰ä¸­çš„è¡Œ
                start_index = self.code_text.index(tk.SEL_FIRST)
                end_index = self.code_text.index(tk.SEL_LAST)
            else:
                # æ²¡æœ‰é€‰ä¸­æ–‡æœ¬ï¼Œå¤„ç†å½“å‰è¡Œ
                current_line = self.code_text.index(tk.INSERT).split('.')[0]
                start_index = f"{current_line}.0"
                end_index = f"{current_line}.end"

            # è·å–èµ·å§‹å’Œç»“æŸè¡Œå·
            start_line = int(start_index.split('.')[0])
            end_line = int(end_index.split('.')[0])

            # æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è¡Œéƒ½å·²æ³¨é‡Š
            all_commented = True
            lines_to_process = []

            for line_num in range(start_line, end_line + 1):
                line_start = f"{line_num}.0"
                line_end = f"{line_num}.end"
                line_content = self.code_text.get(line_start, line_end)

                # è·³è¿‡ç©ºè¡Œ
                if line_content.strip():
                    lines_to_process.append((line_num, line_content))
                    # æ£€æŸ¥æ˜¯å¦ä»¥ # å¼€å¤´ï¼ˆå¿½ç•¥å‰å¯¼ç©ºæ ¼ï¼‰
                    if not line_content.lstrip().startswith('#'):
                        all_commented = False

            # æ ¹æ®å½“å‰çŠ¶æ€å†³å®šæ˜¯æ·»åŠ è¿˜æ˜¯ç§»é™¤æ³¨é‡Š
            for line_num, line_content in lines_to_process:
                line_start = f"{line_num}.0"
                line_end = f"{line_num}.end"

                if all_commented:
                    # ç§»é™¤æ³¨é‡Š
                    # æ‰¾åˆ°ç¬¬ä¸€ä¸ª # çš„ä½ç½®
                    stripped = line_content.lstrip()
                    if stripped.startswith('#'):
                        # è®¡ç®—å‰å¯¼ç©ºæ ¼æ•°é‡
                        leading_spaces = len(line_content) - len(stripped)
                        # ç§»é™¤ # å’Œå¯èƒ½çš„ä¸€ä¸ªç©ºæ ¼
                        if stripped.startswith('# '):
                            new_content = line_content[:leading_spaces] + stripped[2:]
                        else:
                            new_content = line_content[:leading_spaces] + stripped[1:]

                        # æ›¿æ¢è¡Œå†…å®¹
                        self.code_text.delete(line_start, line_end)
                        self.code_text.insert(line_start, new_content)
                else:
                    # æ·»åŠ æ³¨é‡Š
                    # æ‰¾åˆ°ç¬¬ä¸€ä¸ªéç©ºæ ¼å­—ç¬¦çš„ä½ç½®
                    stripped = line_content.lstrip()
                    if stripped:  # éç©ºè¡Œ
                        leading_spaces = len(line_content) - len(stripped)
                        new_content = line_content[:leading_spaces] + '# ' + stripped

                        # æ›¿æ¢è¡Œå†…å®¹
                        self.code_text.delete(line_start, line_end)
                        self.code_text.insert(line_start, new_content)

            # è§¦å‘è¯­æ³•é«˜äº®æ›´æ–°
            self.on_text_change()

        except Exception as e:
            print(f"æ³¨é‡Šåˆ‡æ¢é”™è¯¯: {e}")

        return "break"  # é˜»æ­¢é»˜è®¤è¡Œä¸º

    def handle_shift_tab(self, event):
        """å¤„ç†Shift+Tab - å‡å°‘ç¼©è¿›"""
        try:
            sel_start = self.code_text.index(tk.SEL_FIRST)
            sel_end = self.code_text.index(tk.SEL_LAST)

            start_line = int(sel_start.split('.')[0])
            end_line = int(sel_end.split('.')[0])

            for line_num in range(start_line, end_line + 1):
                line_start = f"{line_num}.0"
                line_end = f"{line_num}.end"
                line_content = self.code_text.get(line_start, line_end)

                # ç§»é™¤è¡Œé¦–çš„4ä¸ªç©ºæ ¼æˆ–åˆ¶è¡¨ç¬¦
                if line_content.startswith("    "):
                    self.code_text.delete(line_start, f"{line_num}.4")
                elif line_content.startswith("\t"):
                    self.code_text.delete(line_start, f"{line_num}.1")

        except tk.TclError:
            # æ²¡æœ‰é€‰ä¸­æ–‡æœ¬ï¼Œå¤„ç†å½“å‰è¡Œ
            current_line = self.code_text.index(tk.INSERT).split('.')[0]
            line_start = f"{current_line}.0"
            line_end = f"{current_line}.end"
            line_content = self.code_text.get(line_start, line_end)

            if line_content.startswith("    "):
                self.code_text.delete(line_start, f"{current_line}.4")
            elif line_content.startswith("\t"):
                self.code_text.delete(line_start, f"{current_line}.1")

        return "break"

    def handle_backspace(self, event):
        """å¤„ç†é€€æ ¼é”® - æ™ºèƒ½åˆ é™¤ç¼©è¿›"""
        # è·å–å½“å‰å…‰æ ‡ä½ç½®
        current_pos = self.code_text.index(tk.INSERT)
        line_num, col_num = current_pos.split('.')
        line_num = int(line_num)
        col_num = int(col_num)

        # è·å–å½“å‰è¡Œå†…å®¹
        line_start = f"{line_num}.0"
        line_end = f"{line_num}.end"
        line_content = self.code_text.get(line_start, line_end)

        # æ£€æŸ¥æ˜¯å¦åœ¨è¡Œé¦–æˆ–åªæœ‰ç©ºæ ¼çš„ä½ç½®
        if col_num > 0:
            # è·å–å…‰æ ‡å‰çš„å†…å®¹
            before_cursor = line_content[:col_num]

            # å¦‚æœå…‰æ ‡å‰åªæœ‰ç©ºæ ¼ï¼Œä¸”ç©ºæ ¼æ•°æ˜¯4çš„å€æ•°ï¼Œåˆ™åˆ é™¤4ä¸ªç©ºæ ¼
            if before_cursor and all(c == ' ' for c in before_cursor) and len(before_cursor) % 4 == 0:
                # åˆ é™¤4ä¸ªç©ºæ ¼ï¼ˆä¸€ä¸ªtabçš„ç­‰ä»·ï¼‰
                delete_start = f"{line_num}.{col_num - 4}"
                delete_end = f"{line_num}.{col_num}"
                self.code_text.delete(delete_start, delete_end)
                return "break"  # é˜»æ­¢é»˜è®¤é€€æ ¼è¡Œä¸º

        # å¦‚æœä¸æ»¡è¶³æ™ºèƒ½åˆ é™¤æ¡ä»¶ï¼Œæ‰§è¡Œé»˜è®¤é€€æ ¼è¡Œä¸º
        return None

    def handle_auto_complete(self, event):
        """å¤„ç†æ‹¬å·è‡ªåŠ¨è¡¥å…¨"""
        char = event.char
        pairs = {
            '(': ')',
            '[': ']',
            '{': '}',
            '"': '"',
            "'": "'"
        }
        
        # è·å–å½“å‰å…‰æ ‡ä½ç½®
        current_pos = self.code_text.index(tk.INSERT)
        
        # æ£€æŸ¥å…‰æ ‡åçš„å­—ç¬¦
        try:
            next_char = self.code_text.get(current_pos)
        except tk.TclError:
            next_char = ''
        
        # å¦‚æœè¾“å…¥çš„æ˜¯å³æ‹¬å·/å¼•å·ï¼Œä¸”å…‰æ ‡åå°±æ˜¯ç›¸åŒçš„å­—ç¬¦ï¼Œåˆ™è·³è¿‡
        if char in [')', ']', '}', '"', "'"] and char == next_char:
            # å°†å…‰æ ‡å‘å‰ç§»åŠ¨ä¸€ä½ï¼Œè·³è¿‡å·²å­˜åœ¨çš„å­—ç¬¦
            new_pos = self.code_text.index(f"{current_pos}+1c")
            self.code_text.mark_set(tk.INSERT, new_pos)
            return "break"  # é˜»æ­¢é»˜è®¤çš„å­—ç¬¦æ’å…¥è¡Œä¸º
        
        # å¦‚æœè¾“å…¥çš„æ˜¯å·¦æ‹¬å·/å¼•å·ï¼Œè¿›è¡Œè‡ªåŠ¨è¡¥å…¨
        if char in pairs:
            # æ’å…¥é…å¯¹å­—ç¬¦
            self.code_text.insert(current_pos, pairs[char])
            # å°†å…‰æ ‡ç§»å›åˆ°é…å¯¹å­—ç¬¦ä¹‹é—´
            self.code_text.mark_set(tk.INSERT, current_pos)
            # æ³¨æ„ï¼šè¿™é‡Œä¸è¦è¿”å›"break"ï¼Œè®©å·¦æ‹¬å·æ­£å¸¸æ’å…¥

    def create_button_area(self, parent):
        """åˆ›å»ºæŒ‰é’®åŒºåŸŸ"""
        button_frame = ttk.Frame(parent)
        button_frame.pack(fill=tk.X, pady=(10, 0))

        # ä¿å­˜æŒ‰é’®
        save_btn = ttk.Button(button_frame, text="ä¿å­˜ (Ctrl+S)", command=self.save_code)
        save_btn.pack(side=tk.RIGHT, padx=(5, 0))

        # å–æ¶ˆæŒ‰é’®
        cancel_btn = ttk.Button(button_frame, text="å–æ¶ˆ", command=self.cancel_edit)
        cancel_btn.pack(side=tk.RIGHT)

        # é—®é—®AIæŒ‰é’®
        ai_btn = ttk.Button(button_frame, text="é—®é—®AI", command=self.ask_ai_for_test_data)
        ai_btn.pack(side=tk.LEFT, padx=(5, 0))

        # é‡ç½®æŒ‰é’®
        reset_btn = ttk.Button(button_frame, text="é‡ç½®æ¨¡æ¿", command=self.reset_template)
        reset_btn.pack(side=tk.LEFT)

    def initialize_code_content(self):
        """åˆå§‹åŒ–ä»£ç å†…å®¹"""
        if self.initial_code.strip():
            # å¦‚æœæœ‰åˆå§‹ä»£ç ï¼Œä½¿ç”¨åˆå§‹ä»£ç 
            self.code_text.insert(1.0, self.initial_code)
        elif self.template_code.strip():
            # å¦‚æœæ²¡æœ‰åˆå§‹ä»£ç ä½†æœ‰æ¨¡æ¿ï¼Œä½¿ç”¨æ¨¡æ¿
            self.code_text.insert(1.0, self.template_code)

        # æ‰§è¡Œè¯­æ³•é«˜äº®
        if self.highlighter:
            self.highlighter.highlight_syntax()

        # è®¾ç½®æ–‡æœ¬é¢œè‰²
        self.code_text.config(foreground="black")

    def reset_template(self):
        """é‡ç½®ä¸ºæ¨¡æ¿ä»£ç """
        if self.template_code.strip():
            self.code_text.delete(1.0, tk.END)
            self.code_text.insert(1.0, self.template_code)
            # è§¦å‘è¯­æ³•é«˜äº®
            self.on_text_change()

    def save_code(self):
        """ä¿å­˜ä»£ç å¹¶å…³é—­ç¼–è¾‘å™¨"""
        if self.code_text:
            self.saved_code = self.code_text.get(1.0, tk.END + "-1c")

            # å¦‚æœæœ‰ä¿å­˜å›è°ƒå‡½æ•°ï¼Œè°ƒç”¨å®ƒ
            if self.on_save:
                self.on_save(self.saved_code)

            # å…³é—­ç¼–è¾‘å™¨çª—å£
            if self.editor_window:
                self.editor_window.destroy()

    def cancel_edit(self):
        """å–æ¶ˆç¼–è¾‘å¹¶å…³é—­ç¼–è¾‘å™¨"""
        if self.editor_window:
            self.editor_window.destroy()

    def handle_undo(self, event):
        """å¤„ç†æ’¤é”€æ“ä½œ"""
        try:
            self.code_text.edit_undo()
            # è§¦å‘è¯­æ³•é«˜äº®æ›´æ–°
            self.on_text_change()
        except tk.TclError:
            # æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ
            pass
        return "break"

    def handle_redo(self, event):
        """å¤„ç†é‡åšæ“ä½œ"""
        try:
            self.code_text.edit_redo()
            # è§¦å‘è¯­æ³•é«˜äº®æ›´æ–°
            self.on_text_change()
        except tk.TclError:
            # æ²¡æœ‰å¯é‡åšçš„æ“ä½œ
            pass
        return "break"

    def get_code(self) -> str:
        """è·å–å½“å‰ä»£ç å†…å®¹"""
        if self.code_text:
            return self.code_text.get(1.0, tk.END + "-1c")
        return self.saved_code

    def set_code(self, code: str):
        """è®¾ç½®ä»£ç å†…å®¹"""
        if self.code_text:
            self.code_text.delete(1.0, tk.END)
            self.code_text.insert(1.0, code)
            # è§¦å‘è¯­æ³•é«˜äº®
            self.on_text_change()

    def ask_ai_for_test_data(self):
        """è°ƒç”¨AIç”Ÿæˆæµ‹è¯•æ•°æ®"""
        try:
            # è·å–APIå¯†é’¥
            api_key = self.get_deepseek_api_key()
            if not api_key:
                return

            # è·å–é¢˜ç›®æè¿°
            problem_description = self.get_problem_description()
            if not problem_description:
                return

            # ä½¿ç”¨æµ‹è¯•æ•°æ®ç”Ÿæˆæç¤ºè¯æ¨¡æ¿
            prompt = generate_test_data_prompt(problem_description)

            # åˆ›å»ºDeepSeekå¯¹è¯æ¡†
            dialog = DeepSeekDialog(self.editor_window or self.parent, api_key, prompt, "")
            dialog.start_generation()  # å¯åŠ¨ä»£ç ç”Ÿæˆ

        except ImportError as e:
            messagebox.showerror("å¯¼å…¥é”™è¯¯",
                                 f"DeepSeekåŠŸèƒ½ä¸å¯ç”¨ï¼Œç¼ºå°‘æ¨¡å—ï¼š{str(e)}\n\nè¯·æ£€æŸ¥ä»¥ä¸‹æ¨¡å—æ˜¯å¦å·²å®‰è£…ï¼š\n- deepseek_dialog\n- ç›¸å…³ä¾èµ–åº“")
        except ModuleNotFoundError as e:
            messagebox.showerror("æ¨¡å—æœªæ‰¾åˆ°",
                                 f"æ‰¾ä¸åˆ°æ¨¡å—ï¼š{str(e)}\n\nè¯·ç¡®ä¿ä»¥ä¸‹æ–‡ä»¶å­˜åœ¨ï¼š\n- gui/deepseek_dialog.py\n- deepseek_api/deepseek_dialog.py")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"è°ƒç”¨DeepSeekæ—¶å‡ºé”™ï¼š{str(e)}")

    def get_deepseek_api_key(self) -> str:
        """è·å–DeepSeek APIå¯†é’¥"""
        # ä½¿ç”¨APIå¯†é’¥ç®¡ç†å™¨
        api_key = ApiKeyManager.get_api_key()
        if api_key:
            return api_key

        # å¦‚æœæ²¡æœ‰ä¿å­˜çš„å¯†é’¥ï¼Œå¼¹å‡ºè¾“å…¥å¯¹è¯æ¡†
        dialog = ApiKeyDialog(self.editor_window or self.parent)
        api_key = dialog.show()

        return api_key

    def get_problem_description(self) -> str:
        """è·å–é¢˜ç›®æè¿°"""
        # åˆ›å»ºé¢˜ç›®æè¿°è¾“å…¥å¯¹è¯æ¡†
        dialog = tk.Toplevel(self.editor_window or self.parent)
        dialog.title("è¾“å…¥é¢˜ç›®æè¿°")
        dialog.geometry("600x400")
        dialog.transient(self.editor_window or self.parent)
        dialog.grab_set()

        # ä¸»æ¡†æ¶
        main_frame = ttk.Frame(dialog, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # è¯´æ˜æ ‡ç­¾
        info_label = ttk.Label(main_frame, text="è¯·è¾“å…¥é¢˜ç›®æè¿°ï¼ŒAIå°†æ ¹æ®æ­¤æè¿°ç”Ÿæˆæµ‹è¯•æ•°æ®ï¼š")
        info_label.pack(pady=(0, 10))

        # æ–‡æœ¬è¾“å…¥æ¡† - é™åˆ¶é«˜åº¦
        text_frame = ttk.Frame(main_frame)
        text_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 20))

        text_widget = tk.Text(text_frame, wrap=tk.WORD, font=('Microsoft YaHei', 10), height=12)
        scrollbar = ttk.Scrollbar(text_frame, orient="vertical", command=text_widget.yview)
        text_widget.config(yscrollcommand=scrollbar.set)

        text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        text_widget.focus_set()

        # æŒ‰é’®æ¡†æ¶ - ç¡®ä¿å›ºå®šåœ¨åº•éƒ¨
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, side=tk.BOTTOM)

        result = {"description": ""}

        def on_confirm():
            result["description"] = text_widget.get(1.0, tk.END).strip()
            dialog.destroy()

        def on_cancel():
            dialog.destroy()

        # ç¡®è®¤å’Œå–æ¶ˆæŒ‰é’®
        ttk.Button(button_frame, text="ç¡®è®¤", command=on_confirm).pack(side=tk.RIGHT, padx=(5, 0))
        ttk.Button(button_frame, text="å–æ¶ˆ", command=on_cancel).pack(side=tk.RIGHT)

        # ç­‰å¾…å¯¹è¯æ¡†å…³é—­
        dialog.wait_window()

        return result["description"]


# ä¾¿æ·å‡½æ•°
def show_code_editor(parent, title: str = "ä»£ç ç¼–è¾‘å™¨",
                     initial_code: str = "",
                     template_code: str = "",
                     width: int = 700, height: int = 600) -> str:
    """æ˜¾ç¤ºä»£ç ç¼–è¾‘å™¨çš„ä¾¿æ·å‡½æ•°
    
    Args:
        parent: çˆ¶çª—å£
        title: ç¼–è¾‘å™¨æ ‡é¢˜
        initial_code: åˆå§‹ä»£ç 
        template_code: æ¨¡æ¿ä»£ç 
        width: çª—å£å®½åº¦
        height: çª—å£é«˜åº¦
    
    Returns:
        ç¼–è¾‘åçš„ä»£ç 
    """
    editor = CodeEditor(parent, title, initial_code, template_code, width=width, height=height)
    return editor.show()
